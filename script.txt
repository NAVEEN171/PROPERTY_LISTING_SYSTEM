# Complete Authentication & Property Management System with Recommendations

**By S. Naveen Kumar, Full Stack Developer**

## Overview
This is a comprehensive real estate platform with JWT-based authentication, advanced property management features, and user recommendation system. Built with Node.js, Express, MongoDB, and Redis caching for optimal performance.

---

## PART A: AUTHENTICATION SYSTEM

## 1. Authentication Router (routes/auth.js)

### What it does:
Sets up API endpoints for authentication operations.

### Step-by-step process:
1. **Import dependencies** - Brings in Express router and authentication controller functions
2. **Create router instance** - Initializes Express router to handle routes
3. **Define POST routes** - Sets up three main endpoints:
   - `/signup` - For user registration
   - `/login` - For user authentication
   - `/refresh-token` - For token renewal
4. **Import middleware** - Includes authentication middleware for protected routes
5. **Export router** - Makes routes available to the main application

---

## 2. Authentication Middleware (middleware/auth.js)

### What it does:
Protects routes by verifying JWT access tokens before allowing access.

### Step-by-step process:
1. **Extract token from headers** - Gets the Authorization header from the request
2. **Parse Bearer token** - Splits "Bearer token" format and extracts the actual token
3. **Check token existence** - Returns 401 error if no token is provided
4. **Verify token signature** - Uses JWT library to validate token with ACCESS_TOKEN_SECRET
5. **Handle token errors** - Identifies if token is expired or invalid
6. **Attach user data** - Adds decoded user information to request object
7. **Continue to next middleware** - Calls next() to proceed to the actual route handler

---

## 3. Authentication Controller Functions

### A. Signup API

**What it does:** Registers new users with encrypted passwords and returns authentication tokens.

**Step-by-step process:**
1. **Extract user data** - Gets name, email, and password from request body
2. **Validate input fields** - Checks if all required fields are provided
3. **Validate password length** - Ensures password is at least 8 characters
4. **Validate email format** - Checks if email contains @ symbol
5. **Connect to database** - Establishes connection to MongoDB
6. **Check existing user** - Searches for user with same email (case-insensitive)
7. **Hash password** - Encrypts password using bcrypt with salt rounds of 10
8. **Create user object** - Prepares new user data with hashed password
9. **Insert into database** - Saves new user to Users collection
10. **Generate tokens** - Creates both access token (30min) and refresh token (1day)
11. **Prepare user response** - Creates user object without sensitive data
12. **Send success response** - Returns user data and tokens with 201 status

### B. Login API

**What it does:** Authenticates existing users and provides access tokens.

**Step-by-step process:**
1. **Extract credentials** - Gets email and password from request body
2. **Validate input** - Ensures both email and password are provided
3. **Connect to database** - Establishes MongoDB connection
4. **Find user** - Searches for user by email (case-insensitive)
5. **Check user existence** - Returns "Invalid credentials" if user not found
6. **Verify password** - Compares provided password with stored hash using bcrypt
7. **Validate password** - Returns "Invalid credentials" if password doesn't match
8. **Generate tokens** - Creates new access and refresh tokens
9. **Prepare user response** - Creates safe user object without password
10. **Send success response** - Returns user data and tokens with 200 status

### C. Refresh Token API

**What it does:** Generates new access tokens using valid refresh tokens.

**Step-by-step process:**
1. **Extract refresh token** - Gets token from Authorization header
2. **Check token presence** - Returns 401 if no refresh token provided
3. **Connect to database** - Establishes MongoDB connection
4. **Verify refresh token** - Validates token signature and expiration
5. **Handle token errors** - Identifies expired vs invalid tokens with specific error codes
6. **Find user in database** - Searches for user associated with the token
7. **Validate user existence** - Ensures user still exists in database
8. **Generate new access token** - Creates fresh access token with 30-minute expiry
9. **Prepare user response** - Creates safe user object
10. **Send new token** - Returns fresh access token and user data

---

## 4. Helper Functions

### A. generateAccessToken()
- **Purpose:** Creates short-lived tokens for API access
- **Payload:** User ID and email
- **Expiry:** 30 minutes
- **Secret:** ACCESS_TOKEN_SECRET environment variable

### B. generateRefreshToken()
- **Purpose:** Creates long-lived tokens for token renewal
- **Payload:** User ID and email  
- **Expiry:** 1 day
- **Secret:** REFRESH_TOKEN_SECRET environment variable

---

## 5. Security Features

### Password Security:
- **Bcrypt hashing** with salt rounds of 10
- **Password validation** (minimum 8 characters)
- **No plain text storage**

### Token Security:
- **Separate secrets** for access and refresh tokens
- **Short access token expiry** (30 minutes)
- **Proper error handling** for expired/invalid tokens
- **Bearer token format** in headers

### Database Security:
- **Case-insensitive email** storage and lookup
- **Duplicate email prevention**
- **Proper error handling** for database operations

---

## 6. API Response Formats

### Success Responses:
- **Signup/Login:** Returns user object, access token, and refresh token
- **Refresh:** Returns new access token and user object
- **All include:** Appropriate success messages and HTTP status codes

### Error Responses:
- **Validation errors:** 400 status with descriptive messages
- **Authentication errors:** 401/403 status with specific error codes
- **Server errors:** 500 status with generic error messages

---

## Usage Flow:
1. **User registers** → Receives access + refresh tokens
2. **User makes API calls** → Uses access token in headers
3. **Access token expires** → Uses refresh token to get new access token
4. **Refresh token expires** → User must login again

This system provides secure, scalable authentication with proper token management and user session handling.

---

## PART B: PROPERTY MANAGEMENT SYSTEM

## 7. Property Router (routes/properties.js)

### What it does:
Sets up API endpoints for complete property CRUD operations with authentication protection.

### Step-by-step process:
1. **Import dependencies** - Brings in Express router and property controller functions
2. **Create router instance** - Initializes Express router for property routes
3. **Define protected routes** - Sets up five main endpoints with authentication:
   - `GET /Get-properties` - Fetch filtered properties with search/pagination
   - `POST /add-property` - Create new property listing
   - `GET /get-property/:propertyId` - Get single property by ID (public access)
   - `PUT /update-property/:propertyId` - Update existing property
   - `DELETE /delete-property/:propertyId` - Delete property
4. **Apply middleware** - Most routes require authentication token
5. **Export router** - Makes property routes available to main application

---

## 8. Property Management APIs

### A. Get Filtered Properties API

**What it does:** Advanced property search with filtering, sorting, pagination, and Redis caching.

**Step-by-step process:**
1. **Generate cache key** - Creates unique key based on query parameters
2. **Check Redis cache** - Returns cached results if available for faster response
3. **Extract query parameters** - Gets 20+ filter options (price, area, location, etc.)
4. **Initialize aggregation** - Sets up MongoDB aggregation pipeline
5. **Build date filters** - Processes available from date using date-fns
6. **Parse boolean filters** - Handles verification status safely
7. **Process array filters** - Splits comma-separated values for multiple selections
8. **Build numeric filters** - Handles price ranges, area ranges, room counts
9. **Create text search** - Implements case-insensitive title search
10. **Handle complex fields** - Processes tags and amenities with string splitting
11. **Apply sorting logic** - Sorts by price, rating, area, or default date
12. **Implement pagination** - Uses MongoDB $facet for count and results
13. **Calculate total pages** - Determines pagination metadata
14. **Cache results** - Stores response in Redis for future requests
15. **Return formatted data** - Sends properties array with pagination info

### B. Create Property API

**What it does:** Creates new property listings with comprehensive validation and authorization.

**Step-by-step process:**
1. **Extract property data** - Gets all property fields from request body
2. **Validate required fields** - Checks 13 mandatory fields for completeness
3. **Validate property type** - Ensures type is one of: Apartment, Villa, Bungalow, Plot, Studio
4. **Validate furnished status** - Checks: Furnished, Semi, Unfurnished
5. **Validate listed by** - Ensures: Owner, Agent, Builder
6. **Validate listing type** - Checks: sale or rent
7. **Validate numeric fields** - Ensures positive prices/areas, non-negative rooms
8. **Validate rating range** - Checks rating is between 0-5 if provided
9. **Format date field** - Converts availableFrom to standardized format
10. **Check duplicate ID** - Prevents properties with same ID
11. **Process amenities** - Converts comma-separated to pipe-separated format
12. **Process tags** - Formats tags for storage
13. **Create property object** - Builds complete property with creator ID
14. **Remove undefined fields** - Cleans object before database insertion
15. **Insert to database** - Saves property to MongoDB
16. **Clear caches** - Invalidates all property-related cached data
17. **Return success response** - Sends created property with generated ID

### C. Get Single Property API

**What it does:** Retrieves individual property details with caching optimization.

**Step-by-step process:**
1. **Extract property ID** - Gets propertyId from URL parameters
2. **Validate ID presence** - Ensures property ID is provided
3. **Generate cache key** - Creates specific key for this property
4. **Check Redis cache** - Returns cached property if available
5. **Connect to database** - Establishes MongoDB connection
6. **Query property** - Finds property by unique ID
7. **Handle not found** - Returns 404 if property doesn't exist
8. **Cache property data** - Stores property in Redis for future requests
9. **Return property** - Sends complete property information

### D. Update Property API

**What it does:** Updates existing properties with ownership verification and validation.

**Step-by-step process:**
1. **Extract parameters** - Gets property ID and update data
2. **Validate property ID** - Ensures ID is provided
3. **Find existing property** - Queries database for property
4. **Check property existence** - Returns 404 if not found
5. **Verify ownership** - Ensures only creator can update property
6. **Validate property type** - Checks if new type is valid (if provided)
7. **Validate furnished status** - Validates furnished field if updated
8. **Validate listed by** - Checks listedBy field if provided
9. **Validate listing type** - Ensures valid listing type if changed
10. **Validate rating** - Checks rating range if updated
11. **Validate numeric fields** - Ensures positive values for price/area
12. **Format date field** - Processes availableFrom date if provided
13. **Process amenities/tags** - Formats comma to pipe separation
14. **Remove restricted fields** - Prevents updating ID, creator, _id
15. **Add timestamp** - Sets updatedAt field
16. **Update database** - Applies changes to MongoDB
17. **Fetch updated property** - Gets complete updated property
18. **Clear caches** - Invalidates single property and filtered properties cache
19. **Return updated data** - Sends updated property information

### E. Delete Property API

**What it does:** Removes properties with proper authorization and cache management.

**Step-by-step process:**
1. **Extract property ID** - Gets propertyId from URL parameters
2. **Validate ID presence** - Ensures property ID is provided
3. **Find property** - Queries database for existing property
4. **Check existence** - Returns 404 if property not found
5. **Verify ownership** - Ensures only creator can delete property
6. **Delete from database** - Removes property from MongoDB
7. **Verify deletion** - Confirms property was actually deleted
8. **Clear single cache** - Removes specific property from Redis
9. **Clear filtered cache** - Invalidates all filtered property caches
10. **Return success** - Confirms successful deletion

---

## 9. Advanced Features

### Redis Caching System:
- **Cache key generation** - Creates unique keys for different query combinations
- **Filtered results caching** - Stores search results to avoid repeated database queries
- **Single property caching** - Caches individual property details
- **Pattern-based invalidation** - Clears related caches when data changes
- **Performance optimization** - Significantly reduces database load

### MongoDB Aggregation Pipeline:
- **Complex filtering** - Handles multiple simultaneous filters
- **Array processing** - Splits and matches comma/pipe separated values
- **Faceted search** - Gets both count and paginated results in single query
- **Flexible sorting** - Multiple sort options with custom logic
- **Text search** - Case-insensitive title matching

### Authorization & Security:
- **JWT-based authentication** - Protects most endpoints with token verification
- **Ownership verification** - Users can only modify their own properties
- **Input validation** - Comprehensive validation for all fields
- **Error handling** - Proper HTTP status codes and error messages

### Data Processing:
- **Date formatting** - Consistent date handling using date-fns
- **String formatting** - Converts between comma and pipe separators
- **Type conversion** - Proper number conversion with validation
- **Field cleaning** - Removes undefined values before database operations

---

## PART C: FAVOURITES MANAGEMENT SYSTEM

## 10. Favourites Router (routes/favourites.js)

### What it does:
Sets up API endpoints for complete favourites CRUD operations with user-specific authentication.

### Step-by-step process:
1. **Import dependencies** - Brings in Express router and favourites controller functions
2. **Create router instance** - Initializes Express router for favourites routes
3. **Define protected routes** - Sets up five authenticated endpoints:
   - `POST /add-favourite/:propertyId` - Add property to user's favourites
   - `GET /` - Get all user's favourite properties
   - `GET /get-favourite/:id` - Get single favourite by ID
   - `PUT /update-favourite/:id` - Update favourite (change property)
   - `DELETE /delete-favourite/:id` - Remove property from favourites
4. **Apply authentication** - All routes require valid JWT token
5. **Export router** - Makes favourites routes available to main application

---

## 11. Favourites Management APIs

### A. Add to Favourites API

**What it does:** Adds properties to user's personal favourites list with duplicate prevention.

**Step-by-step process:**
1. **Extract property ID** - Gets propertyId from URL parameters
2. **Get user ID** - Extracts user ID from authenticated JWT token
3. **Validate property ID** - Ensures propertyId is provided
4. **Connect to database** - Establishes MongoDB connection to Favourites collection
5. **Check existing favourite** - Searches for duplicate entry (same user + property)
6. **Prevent duplicates** - Returns 409 conflict if property already in favourites
7. **Create favourite object** - Builds new favourite with ObjectId userId and string propertyId
8. **Add timestamps** - Sets createdAt and updatedAt to current date
9. **Insert to database** - Saves favourite to MongoDB collection
10. **Clear user cache** - Invalidates user's favourites cache for fresh data
11. **Return success response** - Sends created favourite with all details

### B. Get User Favourites API

**What it does:** Retrieves all favourite properties for authenticated user with caching.

**Step-by-step process:**
1. **Get user ID** - Extracts user ID from JWT token
2. **Generate cache key** - Creates user-specific cache key
3. **Check Redis cache** - Returns cached favourites if available
4. **Log cache miss** - Records when cache needs refresh
5. **Connect to database** - Establishes MongoDB connection
6. **Query user favourites** - Finds all favourites for specific user ID
7. **Sort by recency** - Orders by createdAt in descending order (newest first)
8. **Convert to array** - Processes MongoDB cursor to array
9. **Format response data** - Creates structured response with count and favourites list
10. **Map favourite objects** - Converts _id to id and structures each favourite
11. **Cache results** - Stores formatted data in Redis for future requests
12. **Return favourites** - Sends complete favourites list with count

### C. Get Single Favourite API

**What it does:** Retrieves specific favourite by ID with user ownership verification and caching.

**Step-by-step process:**
1. **Extract favourite ID** - Gets id from URL parameters
2. **Get user ID** - Extracts user ID from JWT token
3. **Validate ObjectId** - Ensures provided ID is valid MongoDB ObjectId format
4. **Generate cache key** - Creates specific cache key for user-favourite combination
5. **Check Redis cache** - Returns cached favourite if available
6. **Connect to database** - Establishes MongoDB connection
7. **Query with ownership check** - Finds favourite by ID AND user ID (security)
8. **Handle not found** - Returns 404 if favourite doesn't exist or doesn't belong to user
9. **Format favourite data** - Structures response with proper field names
10. **Cache single favourite** - Stores favourite in Redis for future requests
11. **Return favourite** - Sends complete favourite information

### D. Update Favourite API

**What it does:** Updates existing favourite with new property ID and ownership verification.

**Step-by-step process:**
1. **Extract parameters** - Gets favourite ID from URL and propertyId from body
2. **Get user ID** - Extracts user ID from JWT token
3. **Validate favourite ID** - Ensures ID is valid MongoDB ObjectId
4. **Validate property ID** - Ensures new propertyId is provided
5. **Connect to database** - Establishes MongoDB connection
6. **Find existing favourite** - Queries for favourite with ID and user ownership
7. **Check ownership** - Returns 404 if favourite not found or doesn't belong to user
8. **Prepare update data** - Creates update object with new propertyId and timestamp
9. **Update database** - Applies changes to MongoDB with user ID verification
10. **Verify update success** - Checks if update actually matched and modified record
11. **Clear related caches** - Invalidates both user favourites list and single favourite cache
12. **Return updated data** - Sends updated favourite with original createdAt and new updatedAt

### E. Delete Favourite API

**What it does:** Removes favourite from user's list with proper authorization and cache cleanup.

**Step-by-step process:**
1. **Extract favourite ID** - Gets id from URL parameters
2. **Get user ID** - Extracts user ID from JWT token
3. **Validate ObjectId** - Ensures provided ID is valid MongoDB ObjectId format
4. **Connect to database** - Establishes MongoDB connection
5. **Delete with ownership check** - Removes favourite only if it belongs to authenticated user
6. **Verify deletion** - Checks if any document was actually deleted
7. **Handle not found** - Returns 404 if favourite wasn't found or didn't belong to user
8. **Clear user cache** - Invalidates user's favourites list cache
9. **Clear single cache** - Removes specific favourite from cache
10. **Return success** - Confirms successful removal

---

## 12. Favourites System Features

### Redis Caching Strategy:
- **User favourites list caching** - Stores complete user favourites with count
- **Single favourite caching** - Caches individual favourite details
- **User-specific cache keys** - Ensures cache isolation between users
- **Pattern-based cache clearing** - Supports bulk cache invalidation
- **Cache miss logging** - Tracks when database queries are needed

### Security & Authorization:
- **JWT-based authentication** - All endpoints require valid access token
- **User ownership verification** - Users can only access/modify their own favourites
- **Duplicate prevention** - Prevents same property being favourited multiple times
- **ObjectId validation** - Ensures proper ID format for database operations

### Database Design:
- **User-property relationship** - Links users to their favourite properties
- **Timestamp tracking** - Records creation and modification times
- **Efficient querying** - Optimized queries with user ID and favourite ID
- **Data consistency** - Proper ObjectId usage for user references

### Performance Optimization:
- **Redis caching** - Reduces database load for frequently accessed favourites
- **Efficient sorting** - Orders favourites by creation date
- **Selective field mapping** - Only returns necessary data fields
- **Cache invalidation** - Strategic cache clearing when data changes

---

## PART D: RECOMMENDATIONS SYSTEM

## 13. Recommendations Router (routes/recommendations.js)

### What it does:
Sets up API endpoints for user search, property recommendations, and recommendation management with full authentication.

### Step-by-step process:
1. **Import dependencies** - Brings in Express router and recommendation controller functions
2. **Create router instance** - Initializes Express router for recommendation routes
3. **Define protected routes** - Sets up three authenticated endpoints:
   - `GET /search-users` - Search users by email for recommendations
   - `POST /recommend-property` - Recommend property to another user
   - `GET /` - Get all received and sent recommendations
4. **Apply authentication** - All routes require valid JWT token
5. **Export router** - Makes recommendation routes available to main application

---

## 14. Recommendations Management APIs

### A. Search Users API

**What it does:** Searches for users by email to enable property recommendations with caching optimization.

**Step-by-step process:**
1. **Extract search term** - Gets searchEmail from query parameters
2. **Validate search input** - Ensures searchEmail is provided, returns 400 if missing
3. **Generate cache key** - Creates lowercase search-specific cache key
4. **Check Redis cache** - Returns cached user results if available for instant response
5. **Connect to database** - Establishes MongoDB connection to Users collection
6. **Build search regex** - Creates case-insensitive regular expression for email matching
7. **Query users** - Searches Users collection with email regex pattern
8. **Project specific fields** - Returns only name and email for privacy (excludes password, etc.)
9. **Limit results** - Restricts results to 15 users to prevent overwhelming responses
10. **Convert to array** - Processes MongoDB cursor to JavaScript array
11. **Cache search results** - Stores results in Redis with 600-second (10-minute) expiry
12. **Log cache operation** - Records successful caching for debugging
13. **Return user list** - Sends matching users array in structured response

### B. Recommend Property API

**What it does:** Creates property recommendations between users with comprehensive validation and duplicate prevention.

**Step-by-step process:**
1. **Extract request data** - Gets email and propertyId from request body
2. **Get recommending user** - Extracts user ID from authenticated JWT token
3. **Validate required fields** - Ensures both email and propertyId are provided
4. **Connect to database** - Establishes connections to Users and Recommendations collections
5. **Find recommending user** - Queries database for user making the recommendation
6. **Validate recommending user** - Returns 404 if recommending user not found
7. **Check self-recommendation** - Prevents users from recommending properties to themselves
8. **Find recipient user** - Searches for recipient by email (case-insensitive)
9. **Validate recipient existence** - Returns 404 if recipient user not found
10. **Check duplicate recommendation** - Searches for existing recommendation with same user, recipient, and property
11. **Prevent duplicate** - Returns 409 conflict if recommendation already exists
12. **Create recommendation object** - Builds recommendation with ObjectId references and metadata
13. **Set recommendation status** - Initializes with "pending" status and current timestamp
14. **Insert to database** - Saves recommendation to MongoDB Recommendations collection
15. **Clear related caches** - Invalidates both recommending and recipient user recommendation caches
16. **Return success response** - Sends recommendation ID and recipient user information

### C. Get Recommendations API

**What it does:** Retrieves all received and sent recommendations for authenticated user with caching and detailed user information.

**Step-by-step process:**
1. **Get user ID** - Extracts user ID from JWT token and converts to ObjectId
2. **Generate cache key** - Creates user-specific cache key for recommendations
3. **Check Redis cache** - Returns cached recommendations if available for faster response
4. **Connect to database** - Establishes connections to Recommendations and Users collections
5. **Query all recommendations** - Finds recommendations where user is either sender or recipient
6. **Sort by recency** - Orders recommendations by createdAt in descending order (newest first)
7. **Convert to array** - Processes MongoDB cursor to JavaScript array
8. **Initialize result arrays** - Creates separate arrays for received and sent recommendations
9. **Process each recommendation** - Iterates through all recommendations to categorize and enrich
10. **Identify recommendation type** - Checks if current user is recipient or sender
11. **Enrich received recommendations** - For received: fetches recommender user details (name, email)
12. **Enrich sent recommendations** - For sent: fetches recipient user details (name, email)
13. **Format recommendation objects** - Structures each recommendation with proper field mapping
14. **Add type indicators** - Marks each recommendation as "received" or "sent" type
15. **Build response object** - Creates comprehensive response with counts and categorized lists
16. **Cache complete response** - Stores response in Redis with 900-second (15-minute) expiry
17. **Return recommendations** - Sends structured response with received/sent lists and counts

---

## 15. Recommendations System Features

### User Search Capabilities:
- **Email-based search** - Finds users by partial email matching
- **Case-insensitive matching** - Handles email searches regardless of case
- **Limited results** - Returns maximum 15 users to prevent overwhelming UI
- **Privacy protection** - Only returns name and email, excludes sensitive data
- **Redis caching** - 10-minute cache for frequently searched emails

### Recommendation Management:
- **Bidirectional tracking** - Tracks both sent and received recommendations
- **Duplicate prevention** - Prevents same property being recommended multiple times to same user
- **Self-recommendation blocking** - Users cannot recommend properties to themselves
- **Status tracking** - Maintains recommendation status (pending by default)
- **Timestamp tracking** - Records when recommendations were created

### Redis Caching Strategy:
- **Search results caching** - Caches user search results for 10 minutes
- **User recommendations caching** - Caches complete recommendation lists for 15 minutes
- **Selective cache invalidation** - Clears specific user caches when new recommendations created
- **Performance optimization** - Reduces database load for frequently accessed data

### Database Design:
- **User relationship tracking** - Links recommending user to recipient user
- **Property reference** - Stores property ID as string for flexible property system integration
- **ObjectId usage** - Proper MongoDB ObjectId handling for user references
- **Indexed queries** - Efficient querying with user ID and compound indexes

### Security & Authorization:
- **JWT-based authentication** - All endpoints require valid access token
- **User validation** - Ensures all referenced users exist in database
- **Ownership verification** - Users can only see their own sent/received recommendations
- **Input validation** - Comprehensive validation for all required fields

### Data Processing:
- **User enrichment** - Fetches and includes user details for recommendations
- **Type categorization** - Separates received vs sent recommendations
- **Count aggregation** - Provides total counts for received and sent recommendations
- **Structured responses** - Consistent API response format with metadata

---

---

## PART E: REDIS HELPER FUNCTIONS SYSTEM

## 16. Redis Helper Functions (helpers/redisFunctions.js)

### What it does:
Provides comprehensive Redis caching utilities with error handling, automatic serialization, and advanced cache management operations.

### Core Functions:

### A. setKey Function

**What it does:** Stores data in Redis with automatic serialization and configurable expiry.

**Step-by-step process:**
1. **Get Redis client** - Establishes connection using connectRedis helper
2. **Process value** - Checks if value is string or converts object/array to JSON string
3. **Set with expiry** - Uses Redis SETEX command to store key-value with expiration time
4. **Handle errors** - Catches and logs Redis connection or operation errors
5. **Return status** - Returns true for success, false for failure
6. **Default expiry** - Uses 1800 seconds (30 minutes) if no expiry specified

### B. getKey Function

**What it does:** Retrieves and automatically deserializes data from Redis cache.

**Step-by-step process:**
1. **Get Redis client** - Establishes connection using connectRedis helper
2. **Retrieve value** - Gets raw string value from Redis using key
3. **Check existence** - Returns null if key doesn't exist in cache
4. **Parse JSON** - Attempts to parse retrieved string as JSON object/array
5. **Handle parse errors** - Returns raw string if JSON parsing fails
6. **Error handling** - Catches Redis errors and returns null
7. **Return data** - Returns parsed object/array or raw string value

### C. deleteKey Function

**What it does:** Removes single key from Redis cache with success verification.

**Step-by-step process:**
1. **Get Redis client** - Establishes connection using connectRedis helper
2. **Delete key** - Uses Redis DEL command to remove specified key
3. **Check deletion result** - Verifies if key was actually deleted (result > 0)
4. **Return status** - Returns true if deleted, false if key didn't exist
5. **Error handling** - Catches and logs Redis errors, returns false

### D. deleteKeysByPattern Function

**What it does:** Bulk deletes multiple keys matching a pattern for cache invalidation.

**Step-by-step process:**
1. **Get Redis client** - Establishes connection using connectRedis helper
2. **Find matching keys** - Uses Redis KEYS command to find all keys matching pattern
3. **Check key count** - Returns 0 if no keys match the pattern
4. **Bulk delete** - Uses Redis DEL command to remove all matching keys at once
5. **Return count** - Returns number of keys successfully deleted
6. **Error handling** - Catches errors and returns 0 for failed operations

### E. keyExists Function

**What it does:** Checks if a specific key exists in Redis cache.

**Step-by-step process:**
1. **Get Redis client** - Establishes connection using connectRedis helper
2. **Check existence** - Uses Redis EXISTS command to verify key presence
3. **Process result** - Converts Redis response (1 or 0) to boolean
4. **Return boolean** - Returns true if key exists, false otherwise
5. **Error handling** - Catches Redis errors and returns false

### F. setExpiry Function

**What it does:** Updates expiration time for existing keys in Redis.

**Step-by-step process:**
1. **Get Redis client** - Establishes connection using connectRedis helper
2. **Set expiration** - Uses Redis EXPIRE command to update key expiry time
3. **Check result** - Verifies if expiry was set successfully (result === 1)
4. **Return status** - Returns true if expiry set, false if key doesn't exist
5. **Error handling** - Catches Redis errors and returns false

---

## 17. Redis System Features

### Data Serialization:
- **Automatic JSON handling** - Seamlessly converts objects/arrays to JSON strings for storage
- **Smart deserialization** - Automatically parses JSON back to objects when retrieving
- **String preservation** - Handles plain strings without unnecessary processing
- **Type flexibility** - Supports any JavaScript data type through JSON serialization

### Error Management:
- **Comprehensive error handling** - All functions include try-catch blocks
- **Detailed error logging** - Logs specific error messages with key/pattern information
- **Graceful degradation** - Returns appropriate default values when Redis operations fail
- **Non-blocking errors** - Application continues functioning even if Redis is unavailable

### Performance Optimization:
- **Connection reuse** - Uses connectRedis helper for efficient connection management
- **Bulk operations** - deleteKeysByPattern handles multiple keys efficiently
- **Configurable expiry** - DEFAULT_EXPIRY constant (1800 seconds) with override capability
- **Pattern-based operations** - Supports wildcard patterns for bulk cache management

### Cache Management:
- **Flexible expiration** - Both default and custom expiry times supported
- **Existence checking** - Verify key presence before operations
- **Pattern deletion** - Bulk invalidation using Redis patterns (e.g., "user:*")
- **Expiry updates** - Extend or modify cache lifetimes for existing keys

### Usage Patterns:
- **Individual key operations** - Single key set/get/delete for specific data
- **Bulk invalidation** - Pattern-based deletion for related cache entries
- **Cache validation** - Check existence before expensive operations
- **Dynamic expiry** - Adjust cache lifetimes based on data importance

---

## 18. Redis Integration Examples

### Property Caching:
```javascript
// Cache filtered properties for 30 minutes
await setKey('filtered_properties:page1:type=apartment', propertiesData);

// Cache single property for 1 hour
await setKey('single_property:123', propertyData, 3600);

// Clear all property caches when new property added
await deleteKeysByPattern('filtered_properties:*');
```

### User Data Caching:
```javascript
// Cache user search results for 10 minutes
await setKey('search_users:john@email.com', usersData, 600);

// Cache user recommendations for 15 minutes
await setKey('recommendations:userId123', recommendationsData, 900);

// Check if user cache exists before querying
if (await keyExists('user_profile:userId123')) {
    userData = await getKey('user_profile:userId123');
}
```

### Favourites Caching:
```javascript
// Cache user favourites
await setKey('user_favourites:userId123', favouritesData);

// Clear user-specific caches when favourites change
await deleteKeysByPattern('user_favourites:userId123*');

// Extend cache expiry for active users
await setExpiry('user_favourites:userId123', 7200);
```

---

## Complete System Integration Flow:
1. **User authenticates** → Gets JWT access token
2. **Browse properties** → Uses filtered property search with Redis caching
3. **Add to favourites** → Saves preferred properties with cache invalidation
4. **Search for users** → Finds other users by email with cached results
5. **Recommend properties** → Shares property recommendations with cache management
6. **View recommendations** → Retrieves cached recommendation lists
7. **Manage favourites** → Update/delete with strategic cache clearing
8. **Property operations** → Create/update/delete properties with pattern-based cache invalidation

This complete real estate platform provides secure user authentication, advanced property management with filtering and caching, personalized favourites functionality, social recommendation features, and comprehensive Redis caching system - all optimized for performance and scalability with robust error handling and cache management strategies.